<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>台灣股票報告</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            padding: 20px;
        }
        .container { max-width: 1200px; margin: 0 auto; }
        .search-box {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        .search-box input {
            padding: 10px 15px;
            font-size: 16px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 200px;
        }
        .search-box button {
            padding: 10px 20px;
            font-size: 16px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .search-box button:hover { background: #0056b3; }
        .search-box button:disabled { background: #ccc; cursor: not-allowed; }
        #etfBtn { background: #28a745; }
        #etfBtn:hover { background: #1e7e34; }
        .loading { text-align: center; padding: 40px; color: #666; }
        .error { background: #fee; color: #c00; padding: 15px; border-radius: 4px; margin-bottom: 20px; }
        .status { margin-left: 10px; color: #666; font-size: 14px; }
        .report {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .report h1 { font-size: 24px; margin-bottom: 5px; color: #333; }
        .report .subtitle { color: #666; margin-bottom: 20px; }
        .report h2 {
            font-size: 18px;
            margin: 20px 0 10px 0;
            padding-bottom: 5px;
            border-bottom: 2px solid #007bff;
            color: #333;
        }
        .profile { background: #f8f9fa; padding: 15px; border-radius: 4px; line-height: 1.6; }
        .price-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }
        .price-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            text-align: center;
        }
        .price-card .label { font-size: 12px; color: #666; margin-bottom: 5px; }
        .price-card .value { font-size: 20px; font-weight: bold; color: #333; }
        .chart-container { margin: 15px 0; height: 300px; }
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            font-size: 14px;
            overflow-x: auto;
            display: block;
        }
        .data-table th, .data-table td {
            padding: 8px 12px;
            text-align: right;
            border: 1px solid #ddd;
            white-space: nowrap;
        }
        .data-table th { background: #f8f9fa; font-weight: 600; }
        .data-table td:first-child, .data-table th:first-child {
            text-align: left;
            background: #f8f9fa;
            font-weight: 500;
            position: sticky;
            left: 0;
        }
        .data-table tr:hover { background: #f5f5f5; }
        .subtitle a { color: #007bff; text-decoration: none; }
        .subtitle a:hover { text-decoration: underline; }
        .select-btn {
            padding: 4px 12px;
            font-size: 13px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .select-btn:hover { background: #0056b3; }
    </style>
</head>
<body>
    <div class="container">
        <div class="search-box">
            <input type="text" id="stockInput" placeholder="股票代號/名稱" />
            <button id="searchBtn" onclick="generateReport()">股票查詢</button>
            <button id="etfBtn" onclick="showDomesticETFs()">台灣成分股ETF</button>
            <span id="status" class="status"></span>
        </div>
        <div id="reportContainer"></div>
    </div>

<script>
// Taiwan Stock Report - Standalone Web Application
const FINMIND_API = 'https://api.finmindtrade.com/api/v4/data';

function setStatus(msg) { document.getElementById('status').textContent = msg; }

function formatNumber(value, decimals = 2) {
    if (value === null || value === undefined || value === '') return '-';
    const num = parseFloat(value);
    if (isNaN(num)) return '-';
    return num.toLocaleString('en-US', { minimumFractionDigits: decimals, maximumFractionDigits: decimals });
}

function formatDate(date) { return date.toISOString().split('T')[0]; }

function convertRocYear(rocYearStr) {
    const match = String(rocYearStr).match(/(\d+)/);
    return match ? parseInt(match[1]) + 1911 : null;
}

async function fetchFinMind(dataset, stockId, startDate, endDate = null) {
    const params = new URLSearchParams({ dataset, data_id: stockId, start_date: startDate });
    if (endDate) params.append('end_date', endDate);

    const url = `${FINMIND_API}?${params}`;
    console.log(`API call: ${url}`);
    const response = await fetch(url);
    if (!response.ok) {
        console.log(`HTTP error: ${response.status}`);
        if (response.status === 402 || response.status === 429) throw new Error('API 請求次數已達上限，請稍後再試');
        throw new Error(`API 連線錯誤 (HTTP ${response.status})`);
    }
    const data = await response.json();
    console.log(`${dataset}: ${data.data ? data.data.length : 0} rows, msg: ${data.msg || 'ok'}`);
    if (data.data && data.data.length > 0) {
        const dates = data.data.map(d => d.date).filter(Boolean);
        console.log(`  date range: ${dates[0]} ~ ${dates[dates.length - 1]}`);
    }
    if (data.status === 402) throw new Error('API 請求次數已達上限，請稍後再試');
    if (data.msg && data.msg.includes('upper limit')) throw new Error('API 請求次數已達上限，請稍後再試');
    if (data.status !== 200) throw new Error(data.msg || 'API Error');
    return data.data;
}

// Search stock by name and return all matches
async function searchStockByName(name) {
    setStatus('搜尋股票中...');
    try {
        const params = new URLSearchParams({ dataset: 'TaiwanStockInfo' });
        const response = await fetch(`${FINMIND_API}?${params}`);
        const data = await response.json();
        if (data.status === 200 && data.data) {
            const matches = data.data.filter(s => s.stock_name && s.stock_name.includes(name));
            // Deduplicate by stock_id
            const seen = new Set();
            const unique = [];
            matches.forEach(s => {
                if (!seen.has(s.stock_id)) {
                    seen.add(s.stock_id);
                    unique.push({ stock_id: s.stock_id, stock_name: s.stock_name, industry: s.industry_category || '' });
                }
            });
            return unique;
        }
    } catch (e) { console.error('Error searching stock:', e); }
    return [];
}

// Show match list for user to select
function showMatchList(matches) {
    let html = `<div class="report">
        <h2>搜尋結果 (${matches.length} 筆)</h2>
        <table class="data-table" style="display:table">
            <thead><tr><th>代號</th><th>名稱</th><th>產業</th><th></th></tr></thead>
            <tbody>`;
    matches.forEach(m => {
        html += `<tr>
            <td style="background:none">${m.stock_id}</td>
            <td style="background:none">${m.stock_name}</td>
            <td style="background:none">${m.industry}</td>
            <td style="background:none"><button class="select-btn" onclick="selectStock('${m.stock_id}')">查詢</button></td>
        </tr>`;
    });
    html += `</tbody></table></div>`;
    document.getElementById('reportContainer').innerHTML = html;
}

// Generate report for a selected stock
function selectStock(stockId) {
    document.getElementById('stockInput').value = stockId;
    generateReport();
}

// Fetch and show domestic ETF list from TWSE
let cachedDomesticETFs = null;

function renderETFList(etfs) {
    let html = `<div class="report">
        <h2>台灣成分股ETF (${etfs.length} 檔)</h2>
        <table style="border-collapse:collapse;margin:15px 0;font-size:14px">
            <thead><tr><th style="padding:6px 10px;border:1px solid #ddd;background:#f8f9fa;white-space:nowrap">代號</th><th style="padding:6px 10px;border:1px solid #ddd;background:#f8f9fa;white-space:nowrap">名稱</th><th style="padding:6px 10px;border:1px solid #ddd;background:#f8f9fa;white-space:nowrap">追蹤指數</th><th style="padding:6px 10px;border:1px solid #ddd;background:#f8f9fa;white-space:nowrap">上市日期</th></tr></thead>
            <tbody>`;
    etfs.forEach(etf => {
        const code = etf.stockNo || '';
        const name = (etf.stockName || '').replace(/證券投資信託基金$/, '').replace(/\(.*?\)/g, '').trim();
        const index = (etf.indexName || '').replace(/\(.*?\)/g, '').trim();
        const listDate = etf.listingDate || '';
        html += `<tr>
            <td style="padding:6px 10px;border:1px solid #ddd;white-space:nowrap"><a href="#" onclick="selectStock('${code}');return false;" style="color:#1a73e8;text-decoration:none;cursor:pointer">${code}</a></td>
            <td style="padding:6px 10px;border:1px solid #ddd;white-space:nowrap"><a href="#" onclick="selectStock('${code}');return false;" style="color:#1a73e8;text-decoration:none;cursor:pointer">${name}</a></td>
            <td style="padding:6px 10px;border:1px solid #ddd;white-space:nowrap">${index}</td>
            <td style="padding:6px 10px;border:1px solid #ddd;white-space:nowrap">${listDate}</td>
        </tr>`;
    });
    html += `</tbody></table></div>`;
    document.getElementById('reportContainer').innerHTML = html;
    setStatus(`找到 ${etfs.length} 檔國內成分股ETF`);
}

async function showDomesticETFs() {
    const btn = document.getElementById('etfBtn');
    btn.disabled = true;

    if (cachedDomesticETFs) {
        renderETFList(cachedDomesticETFs);
        btn.disabled = false;
        return;
    }

    setStatus('取得ETF列表...');
    document.getElementById('reportContainer').innerHTML = '<div class="loading">載入ETF列表中...</div>';

    try {
        // Fetch ETF list from TWSE ETFortune
        let data = null;
        const twseUrl = 'https://www.twse.com.tw/zh/ETFortune/ajaxProductsResult';
        const proxies = [
            url => `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`,
            url => `https://corsproxy.io/?${encodeURIComponent(url)}`,
            url => `https://cors-anywhere.herokuapp.com/${url}`
        ];

        // Try direct first
        try {
            const response = await fetch(twseUrl);
            if (response.ok) {
                const json = await response.json();
                data = json.data || json;
            }
        } catch (e) {
            console.log('Direct TWSE API failed:', e.message);
        }

        // Try proxies if direct failed
        if (!data) {
            for (const makeProxy of proxies) {
                try {
                    const proxyUrl = makeProxy(twseUrl);
                    console.log('Trying proxy:', proxyUrl);
                    setStatus('嘗試透過代理取得ETF列表...');
                    const response = await fetch(proxyUrl);
                    if (response.ok) {
                        const text = await response.text();
                        let parsed;
                        try {
                            const wrapped = JSON.parse(text);
                            parsed = wrapped.contents ? JSON.parse(wrapped.contents) : wrapped;
                        } catch {
                            parsed = JSON.parse(text);
                        }
                        data = parsed.data || parsed;
                        if (data) break;
                    }
                } catch (e) {
                    console.log('Proxy failed:', e.message);
                }
            }
        }

        if (!data || data.length === 0) {
            throw new Error('無法取得ETF資料');
        }

        // Filter for domestic Taiwan ETFs by checking name/index for Taiwan keywords
        const twKeywords = ['臺灣', '台灣', '台股'];
        const domesticETFs = data.filter(d => {
            const name = d.stockName || '';
            const idx = d.indexName || '';
            const code = d.stockNo || '';
            if (/[LRT]$/.test(code)) return false;
            return twKeywords.some(kw => name.includes(kw) || idx.includes(kw));
        });
        domesticETFs.sort((a, b) => (a.stockNo || '').localeCompare(b.stockNo || ''));

        cachedDomesticETFs = domesticETFs;
        renderETFList(domesticETFs);

    } catch (error) {
        console.error('Error fetching ETF list:', error);
        document.getElementById('reportContainer').innerHTML = `<div class="error">取得ETF列表失敗: ${error.message}</div>`;
        setStatus('錯誤');
    } finally {
        btn.disabled = false;
    }
}

// Open ETF basic info page on TWSE
function showETFInfo(stockId) {
    window.open(`https://www.twse.com.tw/zh/products/securities/etf/products/content.html?${stockId}#domestic`, '_blank');
}

// Open ETF holdings page on MoneyDJ
function showETFHoldings(stockId) {
    window.open(`https://www.moneydj.com/ETF/X/Basic/Basic0007B.xdjhtm?etfid=${stockId}.TW`, '_blank');
}

async function getStockInfo(stockId) {
    setStatus('取得股票資訊...');
    try {
        const data = await fetchFinMind('TaiwanStockInfo', stockId, '2020-01-01');
        if (data && data.length > 0) {
            // Debug: log all available fields
            console.log('TaiwanStockInfo all fields:', Object.keys(data[0]));
            console.log('TaiwanStockInfo data:', data[0]);
            return { stock_id: data[0].stock_id, stock_name: data[0].stock_name || stockId, industry: data[0].industry_category || 'N/A' };
        }
    } catch (e) { console.error('Error fetching stock info:', e); }
    return { stock_id: stockId, stock_name: stockId, industry: 'N/A' };
}

async function getPriceSummary(stockId) {
    setStatus('取得股價資料...');
    const endDate = new Date();
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - 60);
    try {
        const data = await fetchFinMind('TaiwanStockPrice', stockId, formatDate(startDate), formatDate(endDate));
        if (data && data.length > 0) {
            const recent = data.slice(-30);
            const closes = recent.map(d => d.close);
            const highs = recent.map(d => d.max);
            const lows = recent.map(d => d.min);
            const volumes = recent.map(d => d.Trading_Volume);
            return {
                current: closes[closes.length - 1],
                high: Math.max(...highs),
                low: Math.min(...lows),
                avg: closes.reduce((a, b) => a + b, 0) / closes.length,
                volume: volumes.reduce((a, b) => a + b, 0) / volumes.length
            };
        }
    } catch (e) { console.error('Error fetching price summary:', e); }
    return null;
}

async function getMonthlyPrices10Y(stockId) {
    setStatus('取得十年股價歷史...');
    const endDate = new Date();
    const startDate = new Date();
    startDate.setFullYear(startDate.getFullYear() - 10);
    try {
        // Fetch in 2-year chunks to avoid row limit
        const monthlyData = {};
        for (let y = startDate.getFullYear(); y <= endDate.getFullYear(); y += 2) {
            const chunkStart = `${y}-01-01`;
            const chunkEnd = `${Math.min(y + 1, endDate.getFullYear())}-12-31`;
            setStatus(`取得股價歷史 ${y}-${Math.min(y + 1, endDate.getFullYear())}...`);
            const data = await fetchFinMind('TaiwanStockPrice', stockId, chunkStart, chunkEnd);
            if (data && data.length > 0) {
                data.filter(d => d.close > 0).forEach(d => {
                    const month = d.date.substring(0, 7);
                    if (!monthlyData[month]) monthlyData[month] = [];
                    monthlyData[month].push(d.close);
                });
            }
        }
        const labels = Object.keys(monthlyData).sort();
        if (labels.length > 0) {
            const prices = labels.map(m => {
                const vals = monthlyData[m];
                return vals.reduce((a, b) => a + b, 0) / vals.length;
            });
            return { labels, prices };
        }
    } catch (e) { console.error('Error fetching monthly prices:', e); }
    return null;
}

async function get10YKeyData(stockId) {
    setStatus('取得財務資料...');
    const endDate = new Date();
    const startDate = new Date();
    startDate.setFullYear(startDate.getFullYear() - 10);
    const startStr = formatDate(startDate);
    const endStr = formatDate(endDate);

    const result = {
        years: [],
        year_end_price: {},
        eps: {},
        pe_ratio: {},
        gross_margin: {},
        annual_revenue: {},
        cash_dividend: {},
        stock_dividend: {},
        dividend_yield: {},
        cash_flow: {},
        debt_ratio: {},
        current_ratio: {}
    };

    try {
        // 1. Year-end prices - fetch in 2-year chunks to avoid row limit
        setStatus('取得年底股價...');
        const yearlyPrices = {};
        for (let y = startDate.getFullYear(); y <= endDate.getFullYear(); y += 2) {
            const chunkStart = `${y}-01-01`;
            const chunkEnd = `${Math.min(y + 1, endDate.getFullYear())}-12-31`;
            setStatus(`取得股價 ${y}-${Math.min(y + 1, endDate.getFullYear())}...`);
            const priceData = await fetchFinMind('TaiwanStockPrice', stockId, chunkStart, chunkEnd);
            if (priceData && priceData.length > 0) {
                const sorted = priceData.filter(d => d.close > 0).sort((a, b) => a.date.localeCompare(b.date));
                sorted.forEach(d => {
                    const yr = parseInt(d.date.substring(0, 4));
                    yearlyPrices[yr] = d.close;
                });
            }
        }
        Object.assign(result.year_end_price, yearlyPrices);

        // 2. Financial statements (EPS, Gross Margin)
        setStatus('取得財務報表...');
        const finData = await fetchFinMind('TaiwanStockFinancialStatements', stockId, startStr, endStr);
        if (finData && finData.length > 0) {
            const epsData = finData.filter(d => d.type === 'EPS');
            const epsYearly = {};
            epsData.forEach(d => {
                const year = parseInt(d.date.substring(0, 4));
                epsYearly[year] = (epsYearly[year] || 0) + parseFloat(d.value);
            });
            Object.keys(epsYearly).forEach(y => {
                result.eps[parseInt(y)] = parseFloat(epsYearly[y].toFixed(2));
            });

            const grossProfitData = finData.filter(d => d.type.includes('GrossProfit') || d.type.includes('營業毛利') || d.type.includes('毛利'));
            const revenueData = finData.filter(d => d.type.includes('Revenue') || d.type.includes('營業收入') || d.type.includes('營收'));
            if (grossProfitData.length > 0 && revenueData.length > 0) {
                const gpYearly = {}, revYearly = {};
                grossProfitData.forEach(d => { const y = parseInt(d.date.substring(0, 4)); gpYearly[y] = (gpYearly[y] || 0) + parseFloat(d.value); });
                revenueData.forEach(d => { const y = parseInt(d.date.substring(0, 4)); revYearly[y] = (revYearly[y] || 0) + parseFloat(d.value); });
                Object.keys(gpYearly).forEach(y => {
                    if (revYearly[y] && revYearly[y] !== 0) result.gross_margin[parseInt(y)] = parseFloat(((gpYearly[y] / revYearly[y]) * 100).toFixed(2));
                });
            }
        }

        // 3. Monthly Revenue
        setStatus('取得營收資料...');
        const revData = await fetchFinMind('TaiwanStockMonthRevenue', stockId, startStr, endStr);
        if (revData && revData.length > 0) {
            const revYearly = {};
            revData.forEach(d => { const y = parseInt(d.date.substring(0, 4)); revYearly[y] = (revYearly[y] || 0) + parseFloat(d.revenue); });
            Object.keys(revYearly).forEach(y => { result.annual_revenue[parseInt(y)] = parseFloat((revYearly[y] / 100000000).toFixed(2)); });
        }

        // 4. Dividends
        setStatus('取得股利資料...');
        const divData = await fetchFinMind('TaiwanStockDividend', stockId, startStr, endStr);
        if (divData && divData.length > 0) {
            divData.forEach(d => {
                let year = d.year ? convertRocYear(String(d.year)) : (d.date ? parseInt(d.date.substring(0, 4)) : null);
                if (year) {
                    const cashDiv = parseFloat(d.CashEarningsDistribution || d.cash_dividend || 0) + parseFloat(d.CashStatutorySurplus || 0);
                    const stockDiv = parseFloat(d.StockEarningsDistribution || d.stock_dividend || 0) + parseFloat(d.StockStatutorySurplus || 0);
                    result.cash_dividend[year] = (result.cash_dividend[year] || 0) + cashDiv;
                    result.stock_dividend[year] = (result.stock_dividend[year] || 0) + stockDiv;
                }
            });
            Object.keys(result.cash_dividend).forEach(y => { result.cash_dividend[y] = parseFloat(result.cash_dividend[y].toFixed(2)); });
            Object.keys(result.stock_dividend).forEach(y => { result.stock_dividend[y] = parseFloat(result.stock_dividend[y].toFixed(2)); });
        }

        // 5. Cash Flow
        setStatus('取得現金流量...');
        const cfData = await fetchFinMind('TaiwanStockCashFlowsStatement', stockId, startStr, endStr);
        if (cfData && cfData.length > 0) {
            const cfFiltered = cfData.filter(d => d.type === 'CashFlowsFromOperatingActivities' || d.type.includes('營業活動'));
            const cfYearly = {};
            cfFiltered.forEach(d => { const y = parseInt(d.date.substring(0, 4)); cfYearly[y] = (cfYearly[y] || 0) + parseFloat(d.value); });
            Object.keys(cfYearly).forEach(y => { result.cash_flow[parseInt(y)] = parseFloat((cfYearly[y] / 100000000).toFixed(2)); });
        }

        // 6. Balance Sheet
        setStatus('取得資產負債表...');
        const bsData = await fetchFinMind('TaiwanStockBalanceSheet', stockId, startStr, endStr);
        if (bsData && bsData.length > 0) {
            bsData.sort((a, b) => a.date.localeCompare(b.date));
            const getYearlyLast = (data, typeNames) => {
                for (const typeName of typeNames) {
                    const filtered = data.filter(d => d.type === typeName);
                    if (filtered.length > 0) {
                        const yearly = {};
                        filtered.forEach(d => { yearly[parseInt(d.date.substring(0, 4))] = parseFloat(d.value); });
                        return yearly;
                    }
                }
                return {};
            };
            const liabilities = getYearlyLast(bsData, ['Liabilities', 'TotalLiabilities', '負債總計', '負債總額']);
            const assets = getYearlyLast(bsData, ['Assets', 'TotalAssets', '資產總計', '資產總額']);
            const currentAssets = getYearlyLast(bsData, ['CurrentAssets', '流動資產合計', '流動資產總計', '流動資產']);
            const currentLiab = getYearlyLast(bsData, ['CurrentLiabilities', '流動負債合計', '流動負債總計', '流動負債']);

            Object.keys(liabilities).forEach(y => { if (assets[y] && assets[y] !== 0) result.debt_ratio[parseInt(y)] = parseFloat(((liabilities[y] / assets[y]) * 100).toFixed(2)); });
            Object.keys(currentAssets).forEach(y => { if (currentLiab[y] && currentLiab[y] !== 0) result.current_ratio[parseInt(y)] = parseFloat((currentAssets[y] / currentLiab[y]).toFixed(2)); });
        }

        // P/E Ratio
        Object.keys(result.year_end_price).forEach(y => {
            const year = parseInt(y);
            if (result.eps[year] && result.eps[year] !== 0) result.pe_ratio[year] = parseFloat((result.year_end_price[year] / result.eps[year]).toFixed(2));
        });

        // Dividend Yield (殖利率) = (Cash Dividend + Stock Dividend) / Year-End Price * 100
        const allDivYears = new Set([...Object.keys(result.cash_dividend), ...Object.keys(result.stock_dividend)]);
        allDivYears.forEach(y => {
            const year = parseInt(y);
            if (result.year_end_price[year] && result.year_end_price[year] !== 0) {
                const totalDiv = (result.cash_dividend[year] || 0) + (result.stock_dividend[year] || 0);
                result.dividend_yield[year] = parseFloat((totalDiv / result.year_end_price[year] * 100).toFixed(2));
            }
        });

        // Collect all years
        const allYears = new Set();
        Object.keys(result).forEach(key => {
            if (key !== 'years' && typeof result[key] === 'object') Object.keys(result[key]).forEach(y => allYears.add(parseInt(y)));
        });
        result.years = Array.from(allYears).sort((a, b) => a - b);

    } catch (e) { console.error('Error fetching key data:', e); }
    return result;
}

function renderReport(data) {
    const { info, priceSummary, monthlyPrices, keyData } = data;

    let html = `
        <div class="report">
            <h1>${info.stock_name} (${info.stock_id})</h1>
            <div class="subtitle">產業: ${info.industry} | <a href="https://tw.stock.yahoo.com/quote/${info.stock_id}.TW" target="_blank">Yahoo 股市</a> | <a href="https://goodinfo.tw/tw/BasicInfo.asp?STOCK_ID=${info.stock_id}" target="_blank">Goodinfo</a>${/^\d{4,}/.test(info.stock_id) && info.stock_id.length >= 4 ? ` | <button class="select-btn" onclick="showETFInfo('${info.stock_id}')">基本資料</button> | <button class="select-btn" onclick="showETFHoldings('${info.stock_id}')">成分股</button>` : ''} | 報告產生時間: ${new Date().toLocaleString()}</div>
    `;

    if (priceSummary) {
        html += `
            <h2>30日股價摘要</h2>
            <div class="price-summary">
                <div class="price-card"><div class="label">目前股價</div><div class="value">${formatNumber(priceSummary.current)}</div></div>
                <div class="price-card"><div class="label">30日最高</div><div class="value">${formatNumber(priceSummary.high)}</div></div>
                <div class="price-card"><div class="label">30日最低</div><div class="value">${formatNumber(priceSummary.low)}</div></div>
                <div class="price-card"><div class="label">30日均價</div><div class="value">${formatNumber(priceSummary.avg)}</div></div>
                <div class="price-card"><div class="label">平均成交量</div><div class="value">${formatNumber(priceSummary.volume / 1000, 0)}K</div></div>
            </div>
        `;
    }

    html += `
        <h2>十年股價走勢</h2>
        <div class="chart-container"><canvas id="priceChart"></canvas></div>
    `;

    if (keyData && keyData.years.length > 0) {
        const years = keyData.years;
        html += `
            <h2>十年關鍵財務數據</h2>
            <table class="data-table">
                <thead><tr><th>指標</th>${years.map(y => `<th>${y}</th>`).join('')}</tr></thead>
                <tbody>
        `;
        const metrics = [
            { label: '年底股價 (元)', key: 'year_end_price' },
            { label: '每股盈餘 (元)', key: 'eps' },
            { label: '本益比', key: 'pe_ratio' },
            { label: '毛利率 (%)', key: 'gross_margin' },
            { label: '年營收 (億元)', key: 'annual_revenue' },
            { label: '現金股利 (元)', key: 'cash_dividend' },
            { label: '股票股利', key: 'stock_dividend' },
            { label: '殖利率 (%)', key: 'dividend_yield' },
            { label: '營業現金流 (億元)', key: 'cash_flow' },
            { label: '負債比率 (%)', key: 'debt_ratio' },
            { label: '流動比率', key: 'current_ratio' }
        ];
        metrics.forEach(m => {
            html += `<tr><td>${m.label}</td>`;
            years.forEach(y => { html += `<td>${formatNumber(keyData[m.key][y])}</td>`; });
            html += `</tr>`;
        });
        html += `</tbody></table>`;
    }

    html += `</div>`;
    document.getElementById('reportContainer').innerHTML = html;

    if (monthlyPrices) {
        const ctx = document.getElementById('priceChart').getContext('2d');

        // Crosshair plugin - draws vertical line with price at top and date at bottom
        const crosshairPlugin = {
            id: 'crosshair',
            afterDraw(chart) {
                if (chart._crosshairX == null) return;
                const drawCtx = chart.ctx;
                const xAxis = chart.scales.x;
                const yAxis = chart.scales.y;

                // Find nearest data point
                const xValue = xAxis.getValueForPixel(chart._crosshairX);
                const index = Math.round(xValue);
                if (index < 0 || index >= chart.data.labels.length) return;
                const label = chart.data.labels[index];
                const price = chart.data.datasets[0].data[index];
                const snapX = xAxis.getPixelForValue(index);

                // Draw vertical line
                drawCtx.save();
                drawCtx.beginPath();
                drawCtx.moveTo(snapX, yAxis.top);
                drawCtx.lineTo(snapX, yAxis.bottom);
                drawCtx.lineWidth = 1;
                drawCtx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
                drawCtx.setLineDash([4, 4]);
                drawCtx.stroke();

                // Draw price label at 1/3 from top
                drawCtx.setLineDash([]);
                drawCtx.font = 'bold 12px sans-serif';
                const priceText = price.toFixed(2) + ' 元';
                const priceWidth = drawCtx.measureText(priceText).width + 10;
                const priceY = yAxis.top + (yAxis.bottom - yAxis.top) / 3;
                // Clamp horizontally so label stays within chart area
                let priceLabelX = snapX - priceWidth / 2;
                if (priceLabelX + priceWidth > xAxis.right) priceLabelX = xAxis.right - priceWidth;
                if (priceLabelX < xAxis.left) priceLabelX = xAxis.left;
                drawCtx.fillStyle = 'rgba(0, 123, 255, 0.85)';
                drawCtx.fillRect(priceLabelX, priceY - 9, priceWidth, 18);
                drawCtx.fillStyle = '#fff';
                drawCtx.textAlign = 'left';
                drawCtx.fillText(priceText, priceLabelX + 5, priceY + 5);

                // Draw date label at bottom
                const dateWidth = drawCtx.measureText(label).width + 10;
                let dateLabelX = snapX - dateWidth / 2;
                if (dateLabelX + dateWidth > xAxis.right) dateLabelX = xAxis.right - dateWidth;
                if (dateLabelX < xAxis.left) dateLabelX = xAxis.left;
                drawCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                drawCtx.fillRect(dateLabelX, yAxis.bottom + 4, dateWidth, 18);
                drawCtx.fillStyle = '#fff';
                drawCtx.fillText(label, dateLabelX + 5, yAxis.bottom + 18);

                drawCtx.restore();
            },
            afterEvent(chart, args) {
                const event = args.event;
                if (event.type === 'mousemove') {
                    chart._crosshairX = event.x;
                    chart.draw();
                } else if (event.type === 'mouseout') {
                    chart._crosshairX = null;
                    chart.draw();
                }
            }
        };

        new Chart(ctx, {
            type: 'line',
            data: {
                labels: monthlyPrices.labels,
                datasets: [{
                    label: '月均價 (元)',
                    data: monthlyPrices.prices,
                    borderColor: '#007bff',
                    backgroundColor: 'rgba(0, 123, 255, 0.1)',
                    fill: true,
                    tension: 0.1,
                    pointRadius: 0,
                    pointHoverRadius: 6,
                    pointHoverBackgroundColor: '#007bff'
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'index',
                    intersect: false
                },
                plugins: {
                    legend: { display: false },
                    tooltip: { enabled: false }
                },
                scales: {
                    x: { display: true, ticks: { callback: function(val, idx) { const label = this.getLabelForValue(val); return label.endsWith('-01') ? label.substring(0, 4) : null; } } },
                    y: { display: true, title: { display: true, text: '股價 (元)' } }
                }
            },
            plugins: [crosshairPlugin]
        });
    }
}

async function generateReport() {
    let stockInput = document.getElementById('stockInput').value.trim().toUpperCase();
    document.getElementById('stockInput').value = stockInput;
    if (!stockInput) { alert('請輸入股票代號或名稱'); return; }

    const btn = document.getElementById('searchBtn');
    btn.disabled = true;
    document.getElementById('reportContainer').innerHTML = '<div class="loading">載入報告中...</div>';

    try {
        // Check if input is a stock ID (digits, optionally followed by letters like 00981A)
        // or a stock name (starts with Chinese characters)
        let stockId = stockInput;
        if (!/^\d+[A-Za-z]*$/.test(stockInput)) {
            // Input is a name, search for matches
            const matches = await searchStockByName(stockInput);
            if (matches.length === 0) {
                throw new Error(`找不到股票: ${stockInput}`);
            } else if (matches.length === 1) {
                stockId = matches[0].stock_id;
            } else {
                // Multiple matches - show list for user to select
                showMatchList(matches);
                setStatus(`找到 ${matches.length} 筆符合結果`);
                btn.disabled = false;
                return;
            }
        }

        const info = await getStockInfo(stockId);
        const priceSummary = await getPriceSummary(stockId);
        const monthlyPrices = await getMonthlyPrices10Y(stockId);
        const keyData = await get10YKeyData(stockId);

        if (!priceSummary && !monthlyPrices && (!keyData || !keyData.years || keyData.years.length === 0)) {
            throw new Error(`查無 ${stockId} 的資料，可能為新上市或 FinMind 尚未收錄`);
        }

        setStatus('股票查詢中...');
        renderReport({ info, priceSummary, monthlyPrices, keyData });
        setStatus('報告產生完成!');
    } catch (error) {
        console.error('Error generating report:', error);
        document.getElementById('reportContainer').innerHTML = `<div class="error">股票查詢時發生錯誤: ${error.message}</div>`;
        setStatus('錯誤');
    } finally {
        btn.disabled = false;
    }
}

document.getElementById('stockInput').addEventListener('keypress', function(e) {
    if (e.key === 'Enter') generateReport();
});
</script>
</body>
</html>
